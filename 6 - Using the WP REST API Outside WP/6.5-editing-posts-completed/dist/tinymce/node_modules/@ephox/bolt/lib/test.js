(function (scope) {
var ephox = scope.ephox = scope.ephox || {};
var bolt = ephox.bolt = ephox.bolt || {};

var def = function (deps, factory) {
    return factory.apply(null, deps);
};
var test = bolt.test = bolt.test || {};
test.report = test.report || {};
test.run = test.run || {};
test.assert = test.assert || {};
test.report.timer = def(
  [
  ],

  function () {
    var elapsed = function (since) {
      var end = new Date();
      var millis = end - since;
      var seconds = Math.floor(millis / 1000);
      var point = Math.floor(millis - (seconds * 1000) / 100);
      var printable = 
        point < 10 ? '00' + point :
              point < 100 ? '0' + point :
                            '' + point;
      return seconds + '.' + printable + 's';
    };

    return {
      elapsed: elapsed
    };
  }
);
test.report.namer = def(
  [
  ],

  function () {
    var format = function (testcase, name) {
      var path = require('path');
      var pretty = path.relative(process.cwd(), testcase);
      return pretty + '#' + name;
    };

    return {
      format: format
    };
  }
);
test.report.errors = def(
  [
  ],

  function (timer, namer) {
    var clean = function (err) {
      var e = err === undefined ? new Error('no error given') : err;

      if (typeof e === 'string')
        return e;
      var s = stack(e);
      if (e.name === 'AssertionError')
        return 'Assertion error' + (e.message ? ' [' + e.message + ']' : '') + ': [' + JSON.stringify(e.expected) + '] ' + e.operator + ' [' + JSON.stringify(e.actual) + ']' + s;
      if (e.name && e.message)
        return s.indexOf(e.name + ': ' + e.message) === 0 ? s : e.name + ': ' + e.message + s;
      if (e.toString)
        return s.indexOf(e.toString()) === 0 ? s : e.toString() + s;
      return JSON.stringify(e) + s;
    };

    var stack = function (e) {
      if (!e.stack)
        return '';
      var lines = e.stack.split('\n').filter(function (line) {
        return line.indexOf('at') !== -1 &&
          !(line.indexOf('/kernel.js') !== -1 ||
            line.indexOf('/test.js') !== -1);
      });
      return '\n' + lines.join('\n');
    };

    return {
      clean: clean
    };
  }
);
test.report.logger = def(
  [
    test.report.errors,
    test.report.timer,
    test.report.namer
  ],

  function (errors, timer, namer) {

    var create = function (verbose, log, errorLog, callback) {
      var initial = new Date();
      var times = {};
      var passed = 0;
      var failed = 0;
      var starttime = 0;

      var vlog = function () {
        if (verbose)
          log.apply(null, arguments);
      };

      var test = function (testcase, name) {
        var starttime = new Date();
        vlog('[' + name + ']');

        var pass = function () {
          ++passed;
          vlog('+ [passed] in ' + timer.elapsed(starttime));
        };

        var fail = function (error) {
          ++failed;
          errorLog('- [failed] : ' + namer.format(testcase, name) + '');
          errorLog('    ' + errors.clean(error).replace(/\n/g, '\n    '));
          errorLog();
        };

        var htmlcompare = function() {
          fail("HTML comparison only supported in Tunic");
        };

        return {
          pass: pass,
          htmlcompare: htmlcompare,
          fail: fail
        };
      };

      var done = function () {
        var success = failed === 0;

        var logType = success ? log : errorLog;
        logType('Ran ' + (passed + failed) + ' tests in ' + timer.elapsed(initial) + ', ' + passed + ' passed, ' + failed + ' failed.');
        callback(success);
      };

      return {
        test: test,
        done: done
      };
    };

    return {
      create: create
    };
  }
);
test.assert.compare = def(
  [
    ephox.bolt.kernel.fp.array,
    ephox.bolt.kernel.fp.object
  ],

  function (arr, obj) {
    var trueType = function (x) {
      var t = typeof x;
      if (t === 'object' && Array.prototype.isPrototypeOf(x))
        return 'array';
      if (x === null)
        return 'null';
      return t;
    };

    var pass = function () {
      return { eq: true };
    };

    var fail = function (why) {
      return { eq: false, why: why };
    };

    var failCompare = function (x, y, prefix) {
      var prefix_ = prefix || 'Values were different';
      return fail(prefix_ + ': [' + String(x) + '] vs [' + String(y) + ']');
    };

    var isEquatableType = function (x) {
      return arr.contains([ 'undefined', 'boolean', 'number', 'string', 'function', 'xml', 'null' ], x);
    };

    var compareArrays = function (x, y) {
      if (x.length !== y.length)
        return failCompare(x.length, y.length, 'Array lengths were different');

      for (var i = 0; i < x.length; i++) {
        var result = doCompare(x[i], y[i]);
        if (!result.eq)
          return fail('Array elements ' + i + ' were different: ' + result.why);
      }
      return pass();
    };

    var sortArray = function (x) {
      var y = x.slice();
      y.sort();
      return y;
    };

    var sortedKeys = function (o) {
      return sortArray(obj.keys(o));
    };

    var compareObjects = function (x, y) {
      var constructorX = x.constructor;
      var constructorY = y.constructor;
      if (constructorX !== constructorY)
        return failCompare(constructorX, constructorY, 'Constructors were different');

      var keysX = sortedKeys(x);
      var keysY = sortedKeys(y);

      var keysResult = compareArrays(keysX, keysY);
      if (!keysResult.eq)
        return failCompare(JSON.stringify(keysX), JSON.stringify(keysY), 'Object keys were different');

      for (var i in x) {
        if (x.hasOwnProperty(i)) {
          var xValue = x[i];
          var yValue = y[i];
          var valueResult = doCompare(xValue, yValue);
          if (!valueResult.eq)
            return fail('Objects were different for key: [' + i + ']: ' + valueResult.why);
        }
      }
      return pass();
    };

    var doCompare = function (x, y) {
      var typeX = trueType(x);
      var typeY = trueType(y);

      if (typeX !== typeY) return failCompare(typeX, typeY, 'Types were different');

      if (isEquatableType(typeX)) {
        if (x !== y) return failCompare(x, y);

      } else if (x == null) {
        if (y !== null) return failCompare(x, y);

      } else if (typeX === 'array') {
        var arrayResult = compareArrays(x, y);
        if (!arrayResult.eq) return arrayResult;

      } else if (typeX === 'object') {
        var objectResult = compareObjects(x, y);
        if (!objectResult.eq) return objectResult;
      }
      return pass();
    };

    var compare = function (x, y) {
      var result = doCompare(x, y);
      var bar = '-----------------------------------------------------------------------';

      return {
        eq: result.eq,
        why: result.why + '\n' + bar + '\n' + JSON.stringify(x) + '\n' + bar + '\n' + JSON.stringify(y) + '\n' + bar + '\n'
      };
    };

    return {
      compare: compare
    };
  }
);
test.assert.assert = def(
  [
    test.assert.compare
  ],

  function (compare) {
    var eq = function (expected, actual, message) {
      var result = compare.compare(expected, actual);
      if (!result.eq) {
        if (message !== undefined)
          throw new Error(message);
        else
          throw new Error(result.why);
      }
    };

    var throws = function (f, expected, message) {
      var token = {};

      try {
        f();
        throw token;
      } catch (e) {
        if (e === token)
          throw new Error(message);
        if (expected !== undefined)
          eq(expected, e, message);
      }
    };

    var succeeds = function (f, message) {
      try {
        f();
      } catch (e) {
        throw new Error(message);
      }
    };

    var fail = function (message) {
      if (message !== undefined)
        throw new Error(message);
      else
        throw new Error('Test failed.');
    };

    var html = function (expected, actual, message) {
      return {
        expected: expected,
        actual: actual,
        message: message
      };
    };

    return {
      eq: eq,
      throws: throws,
      succeeds: succeeds,
      fail: fail,
      html: html
    };
  }
);
test.run.accumulator = def(
  [
    Function('return this;')(),
    ephox.bolt.kernel.fp.functions
  ],

  function (global, fn) {
    var tests = [];

    var push = function (wrapper, testfile, name, replacements, deps, fn) {
      if (typeof deps === 'function' && fn === undefined) {
        fn = deps;
        deps = replacements;
        replacements = {};
      }

      var args = [ wrapper, testfile, name, replacements, deps, fn ];
      tests.push(args);
    };

    var more = function () {
      return tests.length > 0;
    };

    var take = function () {
      if (tests.length > 0)
        return tests.shift();
      throw 'No more, call more() before take().';
    };

    var drain = function (runtest, done) {
      if (more())
        runtest.apply(null, [ fn.curry(drain, runtest, done) ].concat(take()));
      else
        done();
    };

    var register = function (testfile, syncwrapper, asyncwrapper, domwrapper) {

      global.test = function (name, replacements, deps, fn) {
        push(syncwrapper, testfile, name, replacements, deps, fn);
      };

      global.asynctest = function (name, replacements, deps, fn) {
        push(asyncwrapper, testfile, name, replacements, deps, fn);
      };

      global.domtest = function (name, replacements, deps, fn) {
        push(domwrapper, testfile, name, replacements, deps, fn);
      };
    };

    var cancel = function () {
      tests.splice(0);
    };

    var length = function () {
      return tests.length;
    };

    return {
      more: more,
      length: length,
      take: take,
      drain: drain,
      register: register,
      cancel: cancel
    };
  }
);
test.run.wrapper = def(
  [
    Function('return this;')(),
    test.assert.assert
  ],

  function (global, assert) {
    global.assert = assert;

    var resulter = function (testcase, type) {
      return function (returned) {
        if (returned === undefined)
          testcase.pass();
        else if (typeof returned === 'object' && Array.prototype.isPrototypeOf(returned))
          testcase.htmlcompare(returned);
        else
          testcase.fail('Success argument (or sync test return) must be either undefined or an array of HTML comparison objects');
      };
    };

    var sync = function (reporter, testfile, name, f, next) {
      global.define = ephox.bolt.module.api.define;
      global.require = ephox.bolt.module.api.require;
      global.demand = ephox.bolt.module.api.demand;

      return function (/* arguments */) {
        var testcase = reporter.test(testfile, name);
        try {
          resulter(testcase)(f.apply(null, arguments));
        } catch (e) {
          testcase.fail(e);
        } finally {
          global.define = undefined;
          global.require = undefined;
          global.demand = undefined;
          next();
        }
      };
    };

    var async = function (reporter, testfile, name, f, next) {
      global.define = ephox.bolt.module.api.define;
      global.require = ephox.bolt.module.api.require;
      global.demand = ephox.bolt.module.api.demand;

      return function (/* arguments */) {
        var testcase = reporter.test(testfile, name);

        var oncomplete = function (result) {
          return function () {
            result.apply(null, arguments);
            global.define = undefined;
            global.require = undefined;
            global.demand = undefined;
            next();
          };
        };

        var onsuccess = oncomplete(resulter(testcase));
        var onfailure = oncomplete(testcase.fail);

        var args = Array.prototype.slice.call(arguments, 0);

        var promise;
        try {
          promise = f.apply(null, args.concat([ onsuccess, onfailure ]));
        } catch (e) {
          onfailure(e);
        }

        /*
         * Ideally this would require tests to return a promise (as dom tests do) rather than
         * passing success and failure to the test function but we have a huge number of
         * existing tests that need to be converted first
         */
        // IE doesn't support promises, this will at least not fail if a promise isn't returned. Proper fix TBD.
        if (promise !== undefined && promise instanceof Promise) {
          promise.then(onsuccess, onfailure);
        }
      };
    };

    var dom = function (reporter, testfile, name, f, next) {
      var window;
      // I don't want to package jsdom with bolt
      try {
        window = require("jsdom").jsdom().defaultView;
      } catch (e) {
        throw new Error('jsdom must be installed to run dom tests')
      }

      // Transferring all properties from window to global seems like a bad idea.
      // This is a list of commonly used variables in DOM tests that are transferred. It is expected to expand over time.
      const variables = [
        "document",
        "window",
        "Node",
        "Image",
        "navigator",
        "alert",
        "NodeFilter",
        "XMLHttpRequest"
      ];

      variables.map(function (name) {
        global[name] = window[name];
      });

      var oncomplete = function () {
        variables.map(function (name) {
          global[name] = undefined;
        });
        next();
      };

      var wrappedF = function () {
        var promise = f.apply(null, arguments);
        if (!(promise instanceof Promise)) {
          throw 'dom tests must return a promise';
        }
        return promise;
      };

      return async(reporter, testfile, name, wrappedF, oncomplete);
    };

    return {
      sync: sync,
      async: async,
      dom: dom
    };
  }
);
test.run.config = def(
  [
    ephox.bolt.kernel.fp.object,
    ephox.bolt.module.config.mapper,
    ephox.bolt.module.config.specs,
    ephox.bolt.module.util.path
  ],

  function (obj, mapper, specs, path) {
    var sources = function (testfile, replacements) {
      var r = [];
      var testpath = path.dirname(testfile);
      var sourcer = specs.source(testpath);
      obj.each(replacements, function (i, o) {
        var name = path.basename(o);
        var source = sourcer('bolt', i, path.dirname(o), mapper.constant(name));
        r.push(source);
      });

      return r;
    };

    var enricher = function (reader, testfile, replacements) {
      var extra = sources(testfile, replacements);
      return function (done) {
        reader(function (configuration) {
          done({
            types: configuration.types,
            sources: extra.concat(configuration.sources)
          });
        });
      };
    };

    return {
      enricher: enricher
    };
  }
);
test.run.test = def(
  [
    ephox.bolt.module.bootstrap.install,
    ephox.bolt.test.run.config
  ],

  function (install, config) {
    var create = function (builtins, load, loadscript, reporter, reader) {
      
      return function (next, wrapper, testfile, name, replacements, deps, fn) {
        var enriched = config.enricher(reader, testfile, replacements);
        install.install(enriched, builtins, load, loadscript);
        var wrapped = wrapper(reporter, testfile, name, fn, next);
        ephox.bolt.module.api.require(deps, wrapped);
      };
    };

    return {
      create: create
    };
  }
);
test.run.runner = def(
  [
    test.run.accumulator,
    test.run.test,
    test.run.wrapper,
    ephox.bolt.module.config.builtins.commonjs,
    ephox.bolt.loader.transporter.commonjs.read,
    ephox.bolt.loader.api.commonjsevaller.load
  ],

  function (accumulator, test, wrapper, builtins, load, loadscript) {
    var run = function (reporter, reader, tests) {
      var runtest = test.create(builtins, load, loadscript, reporter, reader);

      var path = require('path');

      tests.forEach(function (testfile) {
        var testcase = path.resolve(testfile);
        accumulator.register(testfile, wrapper.sync, wrapper.async, wrapper.dom);
        require(testcase);
      });

      accumulator.drain(runtest, reporter.done);
    };

    return {
      run: run
    };
  }
);
})(Function('return this')());
